<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>–ü–µ—Ä–µ—Ç–∞—Å–æ–≤–∫–∞ –±—É–∫–≤ ‚Äî —É—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ (–ª–∏—à–Ω–∏–µ –±—É–∫–≤—ã)</title>
<meta name="description" content="–¢—Ä–µ–Ω–∞–∂—ë—Ä: —Å–æ–±—Ä–∞—Ç—å —Å–ª–æ–≤–æ –∏–∑ –±—É–∫–≤ + –ª–∏—à–Ω–∏–µ –±—É–∫–≤—ã. –£—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏: 2, 4, 6 –ª–∏—à–Ω–∏—Ö –±—É–∫–≤.">
<style>
:root{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:0}
body{margin:0;padding:18px;background:#f6fbff;color:#07203a}
.container{max-width:980px;margin:20px auto;background:#fff;padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(3,10,18,0.06)}
h1{font-size:20px;margin:0 0 10px}
.top{display:flex;align-items:center;justify-content:space-between;gap:12px}
.instructions{color:#475569;font-size:14px;margin-top:6px}
.board{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap;margin-top:12px}
.slots{display:flex;gap:8px;flex-wrap:nowrap;align-items:center}
.slot{width:56px;height:56px;border:2px dashed #cbd5e1;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:22px;background:#f8fafc;user-select:none;cursor:pointer;transition:background .15s,border-color .15s}
.slot.filled{border-style:solid;background:#fff}
.slot.correct{background:#dcfce7;border-color:#86efac}
.slot.wrong{background:#fee2e2;border-color:#fca5a5}
.tiles{display:flex;gap:8px;flex-wrap:wrap;padding:12px;border-radius:10px;background:#eef2ff;min-height:72px;align-items:center}
.tile{min-width:48px;height:48px;border-radius:10px;background:#fff;border:1px solid #cbd5e1;display:inline-flex;align-items:center;justify-content:center;font-weight:800;cursor:grab;user-select:none;padding:6px 10px}
.tile.dragging{opacity:0.4}
.tile.used{opacity:0.35;cursor:default}
.controls{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
.button{background:#3b82f6;color:#fff;padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.button.ghost{background:#6b7280}
.small{font-size:13px;color:#475569}
.feedback{margin-top:12px;min-height:26px;font-weight:700;text-align:center}
.badges{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.badge{padding:6px 10px;border-radius:999px;background:#f1f5f9;border:1px solid #e2e8f0;font-weight:700}
.home-btn {display:inline-block;background:#10b981;color:#fff;padding:8px 14px;border-radius:10px;font-weight:700;text-decoration:none;font-size:16px;box-shadow:0 4px 10px rgba(0,0,0,0.06);transition: transform 0.1s, background 0.2s;}
.home-btn:hover {opacity:0.95; transform: translateY(-1px);}
.selector{padding:6px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;font-weight:700}
.debug{font-size:12px;color:#7a1f1f;background:#fff7f7;border-radius:8px;padding:8px;margin-top:10px;display:none}
@media (max-width:720px){ .slot{width:44px;height:44px;font-size:18px} .tile{min-width:40px;height:40px} }
</style>
</head>
<body>
<div style="margin:12px auto;max-width:980px;display:flex;gap:12px;align-items:center;justify-content:flex-start">
  <a href="index.html" class="home-btn">üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
</div>

<div class="container" role="application" aria-label="–ü–µ—Ä–µ—Ç–∞—Å–æ–≤–∫–∞ –±—É–∫–≤ ‚Äî —É—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏">
  <div class="top">
    <div>
      <h1>–ü–µ—Ä–µ—Ç–∞—Å–æ–≤–∫–∞ –±—É–∫–≤ ‚Äî —Å–æ–±—Ä–∞—Ç—å —Å–ª–æ–≤–æ</h1>
      <div class="instructions">–°–æ–±–µ—Ä–∏ —Å–ª–æ–≤–æ –∏–∑ –±—É–∫–≤. –£—Ä–æ–≤–Ω–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏—à–Ω–∏—Ö (–æ—Ç–≤–ª–µ–∫–∞—é—â–∏—Ö) –±—É–∫–≤ —Å—Ä–µ–¥–∏ –ø–ª–∏—Ç–æ–∫.</div>
      <div style="margin-top:8px">
        <label class="small" for="difficulty">–£—Ä–æ–≤–µ–Ω—å —Å–ª–æ–∂–Ω–æ—Å—Ç–∏:&nbsp;</label>
        <select id="difficulty" class="selector" aria-label="–í—ã–±–æ—Ä —É—Ä–æ–≤–Ω—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏">
          <option value="2">–õ—ë–≥–∫–∏–π ‚Äî 2 –ª–∏—à–Ω–∏—Ö</option>
          <option value="4">–°—Ä–µ–¥–Ω–∏–π ‚Äî 4 –ª–∏—à–Ω–∏—Ö</option>
          <option value="6">–°–ª–æ–∂–Ω—ã–π ‚Äî 6 –ª–∏—à–Ω–∏—Ö</option>
        </select>
        <span class="small" style="margin-left:12px;color:#475569">–°–ª–æ–≤–∞ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä–µ.</span>
      </div>
    </div>

    <div style="text-align:right">
      <div class="badges">
        <div class="badge" id="remainingBadge">–û—Å—Ç–∞–ª–æ—Å—å —Å–ª–æ–≤: ‚Äî</div>
        <div class="badge" id="repeatsBadge">–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–≤—Ç–æ—Ä–æ–≤: ‚Äî</div>
      </div>
    </div>
  </div>

  <div class="board">
    <div style="flex:1;min-width:240px">
      <div style="display:flex;align-items:center;gap:12px">
        <div class="small">–°–ª–æ—Ç—ã (–∫–ª–∏–∫ ‚Äî —É–¥–∞–ª–∏—Ç—å –±—É–∫–≤—É)</div>
        <div style="margin-left:auto" class="small">–°–ª–æ–≤–æ: <strong id="wordIndex">‚Äî</strong></div>
      </div>

      <div style="margin-top:10px" class="slots" id="slotsContainer" aria-live="polite" aria-label="–°–ª–æ—Ç—ã –¥–ª—è –±—É–∫–≤"></div>

      <div class="controls">
        <button id="playBtn" class="button">‚ñ∂ –ü—Ä–æ—Å–ª—É—à–∞—Ç—å</button>
        <button id="checkBtn" class="button">–ü—Ä–æ–≤–µ—Ä–∏—Ç—å</button>
        <button id="clearBtn" class="button ghost">–û—á–∏—Å—Ç–∏—Ç—å</button>
      </div>

      <div id="feedback" class="feedback" aria-atomic="true"></div>
    </div>

    <div style="flex:1;min-width:260px">
      <div class="small">–ü–ª–∏—Ç–∫–∏ —Å –±—É–∫–≤–∞–º–∏ (–ø–µ—Ä–µ—Ç–∞—â–∏ –∏–ª–∏ –∫–ª–∏–∫–Ω–∏):</div>
      <div class="tiles" id="tilesContainer" aria-label="–ü–ª–∏—Ç–∫–∏ —Å –±—É–∫–≤–∞–º–∏"></div>
    </div>
  </div>

  <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
    <button id="restartBtn" class="button ghost">–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å (—Å–±—Ä–æ—Å)</button>
  </div>

  <div id="debug" class="debug"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', ()=> {
  /* ====== –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ====== */
  const WORDS = ["cat","dog","bed","book","lamp","chair"]; // –ø–æ–¥–±–µ—Ä–∏ —Å–ª–æ–≤–∞ –∏–∑ —É—á–µ–±–Ω–∏–∫–∞
  const MAX_SUCCESS = 2;
  const STORAGE_KEY = 'letters_shuffle_extra_v1';
  const DIFFICULTY_KEY = 'letters_shuffle_extra_v1';
  const ALPHABET = 'abcdefghijklmnopqrstuvwxyz'.split('');

  /* ====== DOM ====== */
  const slotsContainer = document.getElementById('slotsContainer');
  const tilesContainer = document.getElementById('tilesContainer');
  const playBtn = document.getElementById('playBtn');
  const checkBtn = document.getElementById('checkBtn');
  const clearBtn = document.getElementById('clearBtn');
  const restartBtn = document.getElementById('restartBtn');
  const feedback = document.getElementById('feedback');
  const remainingBadge = document.getElementById('remainingBadge');
  const repeatsBadge = document.getElementById('repeatsBadge');
  const wordIndexEl = document.getElementById('wordIndex');
  const difficultySelect = document.getElementById('difficulty');
  const debugEl = document.getElementById('debug');

  /* ====== State ====== */
  let wordState = {}; // {word:{count}}
  let pending = []; // pending words (count < MAX_SUCCESS)
  let current = null;
  let tiles = []; // [{id,letter,used}]
  let tileById = {}; // id -> DOM
  let wordCounter = 0;
  let chosenVoice = null;

  /* ====== Voices helper ====== */
  function loadVoices(){
    if(!('speechSynthesis' in window)) return;
    const vs = speechSynthesis.getVoices();
    if(vs && vs.length){
      chosenVoice = vs.find(v => v.lang && v.lang.toLowerCase().startsWith('en')) || vs[0];
    } else {
      speechSynthesis.onvoiceschanged = ()=> {
        const vs2 = speechSynthesis.getVoices();
        chosenVoice = vs2.find(v => v.lang && v.lang.toLowerCase().startsWith('en')) || vs2[0];
      };
    }
  }

  /* ====== Storage ====== */
  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){
        wordState = JSON.parse(raw);
        WORDS.forEach(w => { if(!wordState[w]) wordState[w] = {count:0}; });
        return;
      }
    }catch(e){ console.warn('loadState error', e); }
    WORDS.forEach(w => wordState[w] = {count:0});
  }
  function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(wordState)); }catch(e){ console.warn('save error', e); } }

  /* ====== Difficulty helper ====== */
  function getSavedDifficulty(){
    try{
      const v = localStorage.getItem(DIFFICULTY_KEY);
      if(v && ['2','4','6'].includes(v)) return Number(v);
    }catch(e){}
    return 2; // default
  }
  function saveDifficulty(n){
    try{ localStorage.setItem(DIFFICULTY_KEY, String(n)); }catch(e){}
  }

  // current extra letters count (based on select)
  function getExtraCount(){
    const val = parseInt(difficultySelect.value,10);
    if([2,4,6].includes(val)) return val;
    return 2;
  }

  /* ====== Utilities ====== */
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function uid(prefix='t'){ return prefix + Math.random().toString(36).slice(2,9); }
  function logDebug(msg){ /*debugEl.style.display='block'; debugEl.textContent += msg + "\\n";*/ console.log(msg); }

  /* ====== Build pending / UI ====== */
  function preparePending(){
    const arr = WORDS.filter(w => (wordState[w].count || 0) < MAX_SUCCESS);
    pending = shuffle(arr.slice());
  }

  // build array of letters = letters of word + EXTRA distractors
  function buildTileLetters(word, extraCount){
    const letters = word.split('');
    const excluded = new Set(letters.map(ch => ch.toLowerCase()));
    // build pool (prefer letters not in word)
    const pool = ALPHABET.filter(ch => !excluded.has(ch));
    const poolCopy = pool.length ? pool.slice() : ALPHABET.slice();
    const extra = [];
    for(let i=0;i<extraCount;i++){
      if(poolCopy.length === 0) poolCopy.push(...ALPHABET);
      const idx = Math.floor(Math.random()*poolCopy.length);
      extra.push(poolCopy.splice(idx,1)[0]);
    }
    return shuffle(letters.concat(extra));
  }

  function buildTilesFor(word){
    tilesContainer.innerHTML = '';
    tiles = [];
    tileById = {};
    const extraCount = getExtraCount();
    const lettersArr = buildTileLetters(word, extraCount);
    lettersArr.forEach(ch => {
      const id = uid('tile');
      const tile = {id, letter: ch.toLowerCase(), used:false};
      tiles.push(tile);
      const div = document.createElement('div');
      div.className = 'tile';
      div.draggable = true;
      div.id = id;
      div.innerText = ch.toUpperCase();
      div.addEventListener('dragstart', (ev)=>{
        ev.dataTransfer.setData('text/plain', id);
        div.classList.add('dragging');
      });
      div.addEventListener('dragend', ()=> div.classList.remove('dragging'));
      div.addEventListener('click', ()=>{
        if(tile.used) return;
        const slot = firstEmptySlot();
        if(slot) placeTileToSlot(id, slot);
      });
      tilesContainer.appendChild(div);
      tileById[id] = div;
    });
  }

  function buildSlotsFor(word){
    slotsContainer.innerHTML = '';
    for(let i=0;i<word.length;i++){
      const s = document.createElement('div');
      s.className = 'slot';
      s.dataset.pos = i;
      s.dataset.expected = word[i];
      s.dataset.tileId = '';
      s.addEventListener('dragover', e => e.preventDefault());
      s.addEventListener('drop', e=>{
        e.preventDefault();
        const tileId = e.dataTransfer.getData('text/plain');
        if(!tileId) return;
        placeTileToSlot(tileId, s);
      });
      s.addEventListener('click', ()=> {
        if(s.dataset.tileId) removeLetterFromSlot(s);
      });
      slotsContainer.appendChild(s);
    }
  }

  function firstEmptySlot(){
    return Array.from(slotsContainer.children).find(s => !s.dataset.tileId);
  }
  function lastFilledSlot(){
    const arr = Array.from(slotsContainer.children);
    for(let i=arr.length-1;i>=0;i--) if(arr[i].dataset.tileId) return arr[i];
    return null;
  }

  function placeTileToSlot(tileId, slot){
    const tileObj = tiles.find(t => t.id === tileId);
    if(!tileObj || tileObj.used) return;
    slot.textContent = tileObj.letter.toUpperCase();
    slot.classList.add('filled');
    slot.dataset.tileId = tileId;
    tileObj.used = true;
    const tileEl = tileById[tileId];
    if(tileEl) tileEl.classList.add('used');
    feedback.textContent = '';
  }

  function removeLetterFromSlot(slot){
    const tileId = slot.dataset.tileId;
    if(!tileId) return;
    slot.textContent = '';
    slot.classList.remove('filled','correct','wrong');
    slot.dataset.tileId = '';
    const tileObj = tiles.find(t=>t.id === tileId);
    if(tileObj) tileObj.used = false;
    const tileEl = tileById[tileId];
    if(tileEl) tileEl.classList.remove('used');
  }

  /* ====== Game logic ====== */
  function loadNext(){
    preparePending();
    if(pending.length === 0){
      feedback.innerHTML = 'üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—Å–µ —Å–ª–æ–≤–∞ –ø—Ä–æ–π–¥–µ–Ω—ã.';
      remainingBadge.textContent = '–û—Å—Ç–∞–ª–æ—Å—å —Å–ª–æ–≤: 0';
      repeatsBadge.textContent = '–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–≤—Ç–æ—Ä–æ–≤: 0';
      slotsContainer.innerHTML = '';
      tilesContainer.innerHTML = '';
      current = null;
      return;
    }
    current = pending[0];
    wordCounter++;
    wordIndexEl.textContent = wordCounter;
    buildSlotsFor(current);
    buildTilesFor(current); // uses current difficulty
    updateBadges();
    speak(current);
  }

  function checkAnswer(){
    if(!current) return;
    const slots = Array.from(slotsContainer.children);
    const empty = slots.some(s => !s.dataset.tileId);
    if(empty){
      feedback.textContent = '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —Å–ª–æ—Ç—ã –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π.';
      feedback.style.color = '#b45309';
      slots.filter(s => !s.dataset.tileId).forEach(s => { s.classList.add('wrong'); setTimeout(()=> s.classList.remove('wrong'),700); });
      return;
    }
    const formed = slots.map(s => s.textContent.toLowerCase()).join('');
    if(formed === current){
      feedback.textContent = '‚úÖ –í–µ—Ä–Ω–æ!';
      feedback.style.color = 'green';
      slots.forEach(s => { s.classList.remove('wrong'); s.classList.add('correct'); });
      wordState[current].count = Math.min(MAX_SUCCESS, (wordState[current].count||0) + 1);
      saveState();
      setTimeout(()=> {
        slots.forEach(s => s.classList.remove('correct'));
        loadNext();
      }, 900);
    } else {
      feedback.textContent = '‚ùå –ï—Å—Ç—å –æ—à–∏–±–∫–∏ ‚Äî –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.';
      feedback.style.color = '#b91c1c';
      const expected = current.split('');
      slots.forEach((s,i) => {
        if(s.textContent.toLowerCase() === expected[i]) s.classList.add('correct');
        else s.classList.add('wrong');
      });
      setTimeout(()=> { slots.forEach(s=> s.classList.remove('wrong')); }, 800);
    }
    updateBadges();
  }

  function clearSlots(){
    Array.from(slotsContainer.children).forEach(s=>{
      if(s.dataset.tileId) removeLetterFromSlot(s);
      s.classList.remove('correct','wrong');
      s.textContent = '';
    });
    feedback.textContent = '';
  }

  function speak(word){
    if(!('speechSynthesis' in window) || !word) return;
    const u = new SpeechSynthesisUtterance(word);
    u.lang = 'en-US';
    u.rate = 0.95;
    if(chosenVoice) u.voice = chosenVoice;
    speechSynthesis.cancel();
    speechSynthesis.speak(u);
    logDebug('Speak: ' + word);
  }

  function updateBadges(){
    const remainingWords = WORDS.filter(w => (wordState[w].count||0) < MAX_SUCCESS).length;
    remainingBadge.textContent = `–û—Å—Ç–∞–ª–æ—Å—å —Å–ª–æ–≤: ${remainingWords}`;
    const repeatsLeft = WORDS.reduce((acc,w) => acc + Math.max(0, MAX_SUCCESS - (wordState[w].count||0)), 0);
    repeatsBadge.textContent = `–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–≤—Ç–æ—Ä–æ–≤: ${repeatsLeft}`;
  }

  function restartAll(){
    if(!confirm('–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å –∏ –æ—á–∏—Å—Ç–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ?')) return;
    localStorage.removeItem(STORAGE_KEY);
    WORDS.forEach(w => wordState[w] = {count:0});
    saveState();
    wordCounter = 0;
    loadNext();
    feedback.textContent = '';
  }

  /* ====== Keyboard support ====== */
  document.addEventListener('keydown', (ev)=>{
    if(!current) return;
    const k = ev.key;
    if(k.length === 1 && /^[a-zA-Z]$/.test(k)){
      const tile = tiles.find(t => !t.used && t.letter.toLowerCase() === k.toLowerCase());
      if(tile){
        const slot = firstEmptySlot();
        if(slot) placeTileToSlot(tile.id, slot);
      }
      ev.preventDefault();
      return;
    }
    if(k === 'Backspace'){
      const last = lastFilledSlot();
      if(last) removeLetterFromSlot(last);
      ev.preventDefault();
      return;
    }
    if(k === 'Enter'){
      checkAnswer();
      ev.preventDefault();
      return;
    }
  });

  /* ====== Handlers ====== */
  playBtn.addEventListener('click', ()=> { if(current) speak(current); });
  checkBtn.addEventListener('click', checkAnswer);
  clearBtn.addEventListener('click', clearSlots);
  restartBtn.addEventListener('click', restartAll);

  // difficulty change: save, rebuild tiles for current word (keep progress)
  difficultySelect.value = String(getSavedDifficulty());
  difficultySelect.addEventListener('change', ()=> {
    const n = getExtraCount();
    saveDifficulty(n);
    // rebuild tiles for current word with new extra count
    if(current){
      buildTilesFor(current);
      feedback.textContent = `–£—Ä–æ–≤–µ–Ω—å –∏–∑–º–µ–Ω—ë–Ω ‚Äî —Ç–µ–ø–µ—Ä—å ${n} –ª–∏—à–Ω–∏—Ö –±—É–∫–≤.`;
    }
  });

  /* ====== Init ====== */
  loadVoices();
  loadState();
  preparePending();
  loadNext();
  updateBadges();
  window.addEventListener('beforeunload', saveState);
});
</script>
</body>
</html>
